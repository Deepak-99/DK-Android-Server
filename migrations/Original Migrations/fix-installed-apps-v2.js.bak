console.log('Starting database fix for installed_apps table...');

const { Sequelize } = require('sequelize');
require('dotenv').config();

// Database configuration
const sequelize = new Sequelize(
  process.env.DB_NAME || 'hawkshaw_db',
  process.env.DB_USER || 'hawkshaw_user',
  process.env.DB_PASSWORD || '',
  {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 3306,
    dialect: 'mysql',
    logging: console.log,
    define: {
      timestamps: false
    }
  }
);

async function fixInstalledAppsTable() {
  const transaction = await sequelize.transaction();
  
  try {
    console.log('\nüîß Starting to fix installed_apps table...');
    
    // 1. Create a backup of the existing table
    console.log('\nüì¶ Creating backup of installed_apps table...');
    await sequelize.query('DROP TABLE IF EXISTS installed_apps_backup', { transaction });
    await sequelize.query('CREATE TABLE installed_apps_backup LIKE installed_apps', { transaction });
    await sequelize.query('INSERT INTO installed_apps_backup SELECT * FROM installed_apps', { transaction });
    console.log('‚úÖ Backup created: installed_apps_backup');
    
    // 2. Create a new temporary table with the correct schema
    console.log('\nüî® Creating new temporary table...');
    await sequelize.query(`
      CREATE TABLE installed_apps_new (
        id INT UNSIGNED NOT NULL AUTO_INCREMENT,
        device_id INT UNSIGNED NOT NULL,
        package_name VARCHAR(255) NOT NULL,
        app_name VARCHAR(255) NOT NULL,
        version_name VARCHAR(100),
        version_code INT,
        install_time DATETIME,
        update_time DATETIME,
        app_size BIGINT,
        data_size BIGINT,
        cache_size BIGINT,
        is_system_app TINYINT(1) DEFAULT 0,
        is_enabled TINYINT(1) DEFAULT 1,
        icon_data TEXT,
        target_sdk_version INT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        sync_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (id),
        UNIQUE KEY idx_installed_apps_device_package (device_id, package_name),
        KEY idx_installed_apps_device (device_id),
        KEY idx_installed_apps_package (package_name),
        KEY idx_installed_apps_system (is_system_app),
        KEY idx_installed_apps_enabled (is_enabled),
        KEY idx_installed_apps_sync_timestamp (sync_timestamp),
        CONSTRAINT fk_installed_apps_device 
          FOREIGN KEY (device_id) REFERENCES devices (device_id)
          ON DELETE CASCADE ON UPDATE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
    `, { transaction });
    
    console.log('‚úÖ Created new table: installed_apps_new');
    
    // 3. Get device mappings
    console.log('\nüîç Getting device ID mappings...');
    const [devices] = await sequelize.query('SELECT device_id, deviceId FROM devices', { transaction });
    const deviceMap = {};
    devices.forEach(device => {
      deviceMap[device.deviceId] = device.device_id;
    });
    
    // 4. Get data from old table and insert into new table
    console.log('\nüîÑ Copying data to new table...');
    const [apps] = await sequelize.query('SELECT * FROM installed_apps', { transaction });
    
    for (const app of apps) {
      const deviceId = deviceMap[app.device_id];
      if (!deviceId) {
        console.warn(`‚ö†Ô∏è  No matching device found for device_id: ${app.device_id}, skipping app: ${app.package_name}`);
        continue;
      }
      
      await sequelize.query(`
        INSERT INTO installed_apps_new (
          id, device_id, package_name, app_name, version_name, version_code,
          install_time, update_time, app_size, data_size, cache_size,
          is_system_app, is_enabled, icon_data, target_sdk_version,
          created_at, updated_at, sync_timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, {
        replacements: [
          app.id,
          deviceId,
          app.package_name,
          app.app_name,
          app.version_name,
          app.version_code,
          app.install_time,
          app.update_time,
          app.app_size,
          app.data_size,
          app.cache_size,
          app.is_system_app,
          app.is_enabled,
          app.icon_data,
          app.target_sdk_version,
          app.created_at,
          app.updated_at,
          app.sync_timestamp || new Date()
        ],
        transaction
      });
    }
    
    // 5. Drop the old table and rename the new one
    console.log('\nüîÑ Replacing tables...');
    await sequelize.query('DROP TABLE IF EXISTS installed_apps_old', { transaction });
    await sequelize.query('RENAME TABLE installed_apps TO installed_apps_old', { transaction });
    await sequelize.query('RENAME TABLE installed_apps_new TO installed_apps', { transaction });
    
    console.log('‚úÖ Table replaced successfully');
    
    // 6. Commit the transaction
    await transaction.commit();
    
    console.log('\n‚ú® Successfully fixed installed_apps table!');
    console.log('   - Old table is now: installed_apps_old');
    console.log('   - Backup is available as: installed_apps_backup');
    
  } catch (error) {
    // Rollback the transaction on error
    await transaction.rollback();
    
    console.error('\n‚ùå Error during migration:', error.message);
    if (error.original) {
      console.error('Original error:', error.original.message);
    }
    
    throw error;
  } finally {
    await sequelize.close();
  }
}

// Run the migration
console.log('üöÄ Starting migration...');
fixInstalledAppsTable()
  .then(() => {
    console.log('‚úÖ Migration completed successfully!');
    process.exit(0);
  })
  .catch(error => {
    console.error('‚ùå Migration failed!');
    console.error(error);
    process.exit(1);
  });